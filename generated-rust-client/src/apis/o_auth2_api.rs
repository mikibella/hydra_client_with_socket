/*
 * Ory Hydra API
 *
 * Documentation for all of Ory Hydra's APIs. 
 *
 * The version of the OpenAPI document: 
 * Contact: hi@ory.sh
 * Generated by: https://openapi-generator.tech
 */

use std::sync::Arc;
use std::borrow::Borrow;
use std::pin::Pin;
#[allow(unused_imports)]
use std::option::Option;

use hyper;
use hyper_util::client::legacy::connect::Connect;
use futures::Future;

use crate::models;
use super::{Error, configuration};
use super::request as __internal_request;

pub struct OAuth2ApiClient<C: Connect>
    where C: Clone + std::marker::Send + Sync + 'static {
    configuration: Arc<configuration::Configuration<C>>,
}

impl<C: Connect> OAuth2ApiClient<C>
    where C: Clone + std::marker::Send + Sync {
    pub fn new(configuration: Arc<configuration::Configuration<C>>) -> OAuth2ApiClient<C> {
        OAuth2ApiClient {
            configuration,
        }
    }
}

pub trait OAuth2Api: Send + Sync {
    fn accept_o_auth2_consent_request(&self, consent_challenge: &str, accept_o_auth2_consent_request: Option<models::AcceptOAuth2ConsentRequest>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>>;
    fn accept_o_auth2_login_request(&self, login_challenge: &str, accept_o_auth2_login_request: Option<models::AcceptOAuth2LoginRequest>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>>;
    fn accept_o_auth2_logout_request(&self, logout_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>>;
    fn create_o_auth2_client(&self, o_auth2_client: models::OAuth2Client) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>>;
    fn delete_o_auth2_client(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn delete_o_auth2_token(&self, client_id: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn delete_trusted_o_auth2_jwt_grant_issuer(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn get_o_auth2_client(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>>;
    fn get_o_auth2_consent_request(&self, consent_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2ConsentRequest, Error>> + Send>>;
    fn get_o_auth2_login_request(&self, login_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2LoginRequest, Error>> + Send>>;
    fn get_o_auth2_logout_request(&self, logout_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2LogoutRequest, Error>> + Send>>;
    fn get_trusted_o_auth2_jwt_grant_issuer(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<models::TrustedOAuth2JwtGrantIssuer, Error>> + Send>>;
    fn introspect_o_auth2_token(&self, token: &str, scope: Option<&str>) -> Pin<Box<dyn Future<Output = Result<models::IntrospectedOAuth2Token, Error>> + Send>>;
    fn list_o_auth2_clients(&self, page_size: Option<i64>, page_token: Option<&str>, client_name: Option<&str>, owner: Option<&str>) -> Pin<Box<dyn Future<Output = Result<Vec<models::OAuth2Client>, Error>> + Send>>;
    fn list_o_auth2_consent_sessions(&self, subject: &str, page_size: Option<i64>, page_token: Option<&str>, login_session_id: Option<&str>) -> Pin<Box<dyn Future<Output = Result<Vec<models::OAuth2ConsentSession>, Error>> + Send>>;
    fn list_trusted_o_auth2_jwt_grant_issuers(&self, max_items: Option<i64>, default_items: Option<i64>, issuer: Option<&str>) -> Pin<Box<dyn Future<Output = Result<Vec<models::TrustedOAuth2JwtGrantIssuer>, Error>> + Send>>;
    fn o_auth2_authorize(&self, ) -> Pin<Box<dyn Future<Output = Result<models::ErrorOAuth2, Error>> + Send>>;
    fn oauth2_token_exchange(&self, grant_type: &str, client_id: Option<&str>, code: Option<&str>, redirect_uri: Option<&str>, refresh_token: Option<&str>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2TokenExchange, Error>> + Send>>;
    fn patch_o_auth2_client(&self, id: &str, json_patch: Vec<models::JsonPatch>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>>;
    fn reject_o_auth2_consent_request(&self, consent_challenge: &str, reject_o_auth2_request: Option<models::RejectOAuth2Request>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>>;
    fn reject_o_auth2_login_request(&self, login_challenge: &str, reject_o_auth2_request: Option<models::RejectOAuth2Request>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>>;
    fn reject_o_auth2_logout_request(&self, logout_challenge: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn revoke_o_auth2_consent_sessions(&self, subject: &str, client: Option<&str>, all: Option<bool>) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn revoke_o_auth2_login_sessions(&self, subject: Option<&str>, sid: Option<&str>) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn revoke_o_auth2_token(&self, token: &str, client_id: Option<&str>, client_secret: Option<&str>) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>>;
    fn set_o_auth2_client(&self, id: &str, o_auth2_client: models::OAuth2Client) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>>;
    fn set_o_auth2_client_lifespans(&self, id: &str, o_auth2_client_token_lifespans: Option<models::OAuth2ClientTokenLifespans>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>>;
    fn trust_o_auth2_jwt_grant_issuer(&self, trust_o_auth2_jwt_grant_issuer: Option<models::TrustOAuth2JwtGrantIssuer>) -> Pin<Box<dyn Future<Output = Result<models::TrustedOAuth2JwtGrantIssuer, Error>> + Send>>;
}

impl<C: Connect>OAuth2Api for OAuth2ApiClient<C>
    where C: Clone + std::marker::Send + Sync {
    #[allow(unused_mut)]
    fn accept_o_auth2_consent_request(&self, consent_challenge: &str, accept_o_auth2_consent_request: Option<models::AcceptOAuth2ConsentRequest>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/oauth2/auth/requests/consent/accept".to_string())
        ;
        req = req.with_query_param("consent_challenge".to_string(), consent_challenge.to_string());
        req = req.with_body_param(accept_o_auth2_consent_request);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn accept_o_auth2_login_request(&self, login_challenge: &str, accept_o_auth2_login_request: Option<models::AcceptOAuth2LoginRequest>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/oauth2/auth/requests/login/accept".to_string())
        ;
        req = req.with_query_param("login_challenge".to_string(), login_challenge.to_string());
        req = req.with_body_param(accept_o_auth2_login_request);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn accept_o_auth2_logout_request(&self, logout_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/oauth2/auth/requests/logout/accept".to_string())
        ;
        req = req.with_query_param("logout_challenge".to_string(), logout_challenge.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn create_o_auth2_client(&self, o_auth2_client: models::OAuth2Client) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::POST, "/admin/clients".to_string())
        ;
        req = req.with_body_param(o_auth2_client);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn delete_o_auth2_client(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::DELETE, "/admin/clients/{id}".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn delete_o_auth2_token(&self, client_id: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::DELETE, "/admin/oauth2/tokens".to_string())
        ;
        req = req.with_query_param("client_id".to_string(), client_id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn delete_trusted_o_auth2_jwt_grant_issuer(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::DELETE, "/admin/trust/grants/jwt-bearer/issuers/{id}".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn get_o_auth2_client(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/clients/{id}".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn get_o_auth2_consent_request(&self, consent_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2ConsentRequest, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/oauth2/auth/requests/consent".to_string())
        ;
        req = req.with_query_param("consent_challenge".to_string(), consent_challenge.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn get_o_auth2_login_request(&self, login_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2LoginRequest, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/oauth2/auth/requests/login".to_string())
        ;
        req = req.with_query_param("login_challenge".to_string(), login_challenge.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn get_o_auth2_logout_request(&self, logout_challenge: &str) -> Pin<Box<dyn Future<Output = Result<models::OAuth2LogoutRequest, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/oauth2/auth/requests/logout".to_string())
        ;
        req = req.with_query_param("logout_challenge".to_string(), logout_challenge.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn get_trusted_o_auth2_jwt_grant_issuer(&self, id: &str) -> Pin<Box<dyn Future<Output = Result<models::TrustedOAuth2JwtGrantIssuer, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/trust/grants/jwt-bearer/issuers/{id}".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn introspect_o_auth2_token(&self, token: &str, scope: Option<&str>) -> Pin<Box<dyn Future<Output = Result<models::IntrospectedOAuth2Token, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::POST, "/admin/oauth2/introspect".to_string())
        ;
        if let Some(param_value) = scope {
            req = req.with_form_param("scope".to_string(), param_value.to_string());
        }
        req = req.with_form_param("token".to_string(), token.to_string());

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn list_o_auth2_clients(&self, page_size: Option<i64>, page_token: Option<&str>, client_name: Option<&str>, owner: Option<&str>) -> Pin<Box<dyn Future<Output = Result<Vec<models::OAuth2Client>, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/clients".to_string())
        ;
        if let Some(ref s) = page_size {
            let query_value = s.to_string();
            req = req.with_query_param("page_size".to_string(), query_value);
        }
        if let Some(ref s) = page_token {
            let query_value = s.to_string();
            req = req.with_query_param("page_token".to_string(), query_value);
        }
        if let Some(ref s) = client_name {
            let query_value = s.to_string();
            req = req.with_query_param("client_name".to_string(), query_value);
        }
        if let Some(ref s) = owner {
            let query_value = s.to_string();
            req = req.with_query_param("owner".to_string(), query_value);
        }

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn list_o_auth2_consent_sessions(&self, subject: &str, page_size: Option<i64>, page_token: Option<&str>, login_session_id: Option<&str>) -> Pin<Box<dyn Future<Output = Result<Vec<models::OAuth2ConsentSession>, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/oauth2/auth/sessions/consent".to_string())
        ;
        if let Some(ref s) = page_size {
            let query_value = s.to_string();
            req = req.with_query_param("page_size".to_string(), query_value);
        }
        if let Some(ref s) = page_token {
            let query_value = s.to_string();
            req = req.with_query_param("page_token".to_string(), query_value);
        }
        req = req.with_query_param("subject".to_string(), subject.to_string());
        if let Some(ref s) = login_session_id {
            let query_value = s.to_string();
            req = req.with_query_param("login_session_id".to_string(), query_value);
        }

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn list_trusted_o_auth2_jwt_grant_issuers(&self, max_items: Option<i64>, default_items: Option<i64>, issuer: Option<&str>) -> Pin<Box<dyn Future<Output = Result<Vec<models::TrustedOAuth2JwtGrantIssuer>, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/admin/trust/grants/jwt-bearer/issuers".to_string())
        ;
        if let Some(ref s) = max_items {
            let query_value = s.to_string();
            req = req.with_query_param("MaxItems".to_string(), query_value);
        }
        if let Some(ref s) = default_items {
            let query_value = s.to_string();
            req = req.with_query_param("DefaultItems".to_string(), query_value);
        }
        if let Some(ref s) = issuer {
            let query_value = s.to_string();
            req = req.with_query_param("issuer".to_string(), query_value);
        }

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn o_auth2_authorize(&self, ) -> Pin<Box<dyn Future<Output = Result<models::ErrorOAuth2, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::GET, "/oauth2/auth".to_string())
        ;

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn oauth2_token_exchange(&self, grant_type: &str, client_id: Option<&str>, code: Option<&str>, redirect_uri: Option<&str>, refresh_token: Option<&str>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2TokenExchange, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::POST, "/oauth2/token".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(param_value) = client_id {
            req = req.with_form_param("client_id".to_string(), param_value.to_string());
        }
        if let Some(param_value) = code {
            req = req.with_form_param("code".to_string(), param_value.to_string());
        }
        req = req.with_form_param("grant_type".to_string(), grant_type.to_string());
        if let Some(param_value) = redirect_uri {
            req = req.with_form_param("redirect_uri".to_string(), param_value.to_string());
        }
        if let Some(param_value) = refresh_token {
            req = req.with_form_param("refresh_token".to_string(), param_value.to_string());
        }

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn patch_o_auth2_client(&self, id: &str, json_patch: Vec<models::JsonPatch>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PATCH, "/admin/clients/{id}".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());
        req = req.with_body_param(json_patch);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn reject_o_auth2_consent_request(&self, consent_challenge: &str, reject_o_auth2_request: Option<models::RejectOAuth2Request>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/oauth2/auth/requests/consent/reject".to_string())
        ;
        req = req.with_query_param("consent_challenge".to_string(), consent_challenge.to_string());
        req = req.with_body_param(reject_o_auth2_request);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn reject_o_auth2_login_request(&self, login_challenge: &str, reject_o_auth2_request: Option<models::RejectOAuth2Request>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2RedirectTo, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/oauth2/auth/requests/login/reject".to_string())
        ;
        req = req.with_query_param("login_challenge".to_string(), login_challenge.to_string());
        req = req.with_body_param(reject_o_auth2_request);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn reject_o_auth2_logout_request(&self, logout_challenge: &str) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/oauth2/auth/requests/logout/reject".to_string())
        ;
        req = req.with_query_param("logout_challenge".to_string(), logout_challenge.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn revoke_o_auth2_consent_sessions(&self, subject: &str, client: Option<&str>, all: Option<bool>) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::DELETE, "/admin/oauth2/auth/sessions/consent".to_string())
        ;
        req = req.with_query_param("subject".to_string(), subject.to_string());
        if let Some(ref s) = client {
            let query_value = s.to_string();
            req = req.with_query_param("client".to_string(), query_value);
        }
        if let Some(ref s) = all {
            let query_value = s.to_string();
            req = req.with_query_param("all".to_string(), query_value);
        }
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn revoke_o_auth2_login_sessions(&self, subject: Option<&str>, sid: Option<&str>) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::DELETE, "/admin/oauth2/auth/sessions/login".to_string())
        ;
        if let Some(ref s) = subject {
            let query_value = s.to_string();
            req = req.with_query_param("subject".to_string(), query_value);
        }
        if let Some(ref s) = sid {
            let query_value = s.to_string();
            req = req.with_query_param("sid".to_string(), query_value);
        }
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn revoke_o_auth2_token(&self, token: &str, client_id: Option<&str>, client_secret: Option<&str>) -> Pin<Box<dyn Future<Output = Result<(), Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::POST, "/oauth2/revoke".to_string())
            .with_auth(__internal_request::Auth::Basic)
            .with_auth(__internal_request::Auth::Oauth)
        ;
        if let Some(param_value) = client_id {
            req = req.with_form_param("client_id".to_string(), param_value.to_string());
        }
        if let Some(param_value) = client_secret {
            req = req.with_form_param("client_secret".to_string(), param_value.to_string());
        }
        req = req.with_form_param("token".to_string(), token.to_string());
        req = req.returns_nothing();

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn set_o_auth2_client(&self, id: &str, o_auth2_client: models::OAuth2Client) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/clients/{id}".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());
        req = req.with_body_param(o_auth2_client);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn set_o_auth2_client_lifespans(&self, id: &str, o_auth2_client_token_lifespans: Option<models::OAuth2ClientTokenLifespans>) -> Pin<Box<dyn Future<Output = Result<models::OAuth2Client, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::PUT, "/admin/clients/{id}/lifespans".to_string())
        ;
        req = req.with_path_param("id".to_string(), id.to_string());
        req = req.with_body_param(o_auth2_client_token_lifespans);

        req.execute(self.configuration.borrow())
    }

    #[allow(unused_mut)]
    fn trust_o_auth2_jwt_grant_issuer(&self, trust_o_auth2_jwt_grant_issuer: Option<models::TrustOAuth2JwtGrantIssuer>) -> Pin<Box<dyn Future<Output = Result<models::TrustedOAuth2JwtGrantIssuer, Error>> + Send>> {
        let mut req = __internal_request::Request::new(hyper::Method::POST, "/admin/trust/grants/jwt-bearer/issuers".to_string())
        ;
        req = req.with_body_param(trust_o_auth2_jwt_grant_issuer);

        req.execute(self.configuration.borrow())
    }

}
